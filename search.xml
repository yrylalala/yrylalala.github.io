<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>821.字符的最短距离</title>
    <url>/2021/03/03/821.%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a class="link"   href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/" >https://leetcode-cn.com/problems/shortest-distance-to-a-character/<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：S &#x3D; &quot;loveleetcode&quot;, C &#x3D; &#39;e&#39;</span><br><span class="line">输出：[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">字符串 S 的长度范围为 [1, 10000]。</span><br><span class="line">C 是一个单字符，且保证是字符串 S 里的字符。</span><br><span class="line">S 和 C 中的所有字母均为小写字母。</span><br></pre></td></tr></table></figure>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>数组遍历</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>遍历该字符串，找到对应的字符，然后以该字符的位置向左右扩展，计算距离</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li> 需要注意遍历的判断条件</li>
</ul>
<ol>
<li>当遍历到的字符位置距离值还是 0 的时候填充距离，并继续扩展</li>
<li>当遍历到的字符位置距离值小于已填充的距离值值时填充距离，并继续扩展</li>
<li>当遇到字符串左右边界的时候返回</li>
<li>当遇到同样字符 C 的时候返回</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：Java</li>
</ul>
<p>Java Code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (C == S.charAt(i)) &#123;</span><br><span class="line">                left = i - <span class="number">1</span>;</span><br><span class="line">                right = i + <span class="number">1</span>;</span><br><span class="line">                ret[i] = <span class="number">0</span>;</span><br><span class="line">                dist = <span class="number">1</span>;</span><br><span class="line">               <span class="comment">/* 向左延伸 +*/</span></span><br><span class="line">                <span class="keyword">while</span> ((left &gt;= <span class="number">0</span>) &amp;&amp; </span><br><span class="line">                       (S.charAt(left) != C) &amp;&amp;</span><br><span class="line">                       (ret[left] == <span class="number">0</span> || ret[left] &gt; dist)) &#123;</span><br><span class="line">                        ret[left] = dist;</span><br><span class="line">                        dist++;</span><br><span class="line">                        left--;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">/* 向右延伸 */</span></span><br><span class="line">                dist = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ((right &lt; S.length()) &amp;&amp; </span><br><span class="line">                       (S.charAt(right) != C) &amp;&amp; </span><br><span class="line">                       (ret[right] == <span class="number">0</span> || ret[right] &gt; dist)) &#123;</span><br><span class="line">                    ret[right] = dist;</span><br><span class="line">                    dist++;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong><br>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：O(n)，理论上是遍历两遍数组，循环查找字符 C，然后再从 C 开始扩展。</li>
<li>空间复杂度：O(n)，只需要额外只用一个数组空间用来存返回值即可。</li>
</ul>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h3><p>另外一个比较巧妙的办法是<br>先从头遍历一遍字符串，计算每个位置的字符到前一个字符 C 的距离<br>再从尾遍历一遍字符串，再用同样方法计算距离，若距离小于已填充的，就替换成新的距离</p>
<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li> 怎么保证两头的字符位置计算</li>
</ul>
<ol>
<li>从头开始遍历时，距离初始值为 -10001，因为字符最大长度是 10000，这样在出现第一个字符 C 之前的距离值全为负值<br> 而倒过来遍历的时候若距离值为负数，就可以直接覆盖</li>
<li>从尾开始遍历时，距离初始值为 10001，这样在开始遍历的时候，一定是小于已填充的距离值</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：C++  </li>
</ul>
<p>C++ Code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shortestToChar</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">char</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distVec</span><span class="params">(S.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从头到尾遍历</span></span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">-10001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == C) &#123;</span><br><span class="line">                distVec[i] = <span class="number">0</span>;</span><br><span class="line">                dist = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                distVec[i] = dist;</span><br><span class="line">                dist++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尾到头遍历</span></span><br><span class="line">        dist = <span class="number">10001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == C) &#123;</span><br><span class="line">                distVec[i] = <span class="number">0</span>;</span><br><span class="line">                dist = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (distVec[i] &lt; <span class="number">0</span> || distVec[i] &gt; dist) &#123;</span><br><span class="line">                    distVec[i] = dist;</span><br><span class="line">                    dist++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distVec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong><br>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：O(n)，需要遍历两边数组</li>
<li>空间复杂度：O(n)，需要返回值的额外空间</li>
</ul>
]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构及算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/03/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="过程理解"><a href="#过程理解" class="headerlink" title="过程理解"></a>过程理解</h3><p>​        归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br><strong>理解归并排序之前最好先对二分法有一定的理解，对于代码实现也有帮助。</strong> </p>
<p>以下这张图的步骤描述，相对来说比较清晰：<br><img src="/images/mergeSort1.jpeg" alt="mergeSort1"><br><em>图引自 <a class="link"   href="https://zhuanlan.zhihu.com/p/124356219" >【算法】排序算法之归并排序<i class="fas fa-external-link-alt"></i></a></em> </p>
<p>​        归并排序是用分治思想，分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之。因此规避排序在每一层递归上有三个步骤：</p>
<ul>
<li><strong>分解（Divide）</strong>：将 n 个元素分成个含 n/2 个元素的子序列。</li>
<li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li>
<li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li>
</ul>
<p><img src="/images/mergeSort2.png" alt="mergeSort2"><br><em>图引自 <a class="link"   href="https://www.cnblogs.com/chengxiao/p/6194356.html" >图解排序算法(四)之归并排序<i class="fas fa-external-link-alt"></i></a></em> </p>
<p>转为需要代码实现的时候，即可以借助以下图片来理解一下，不管是使用递归还是使用迭代。<br><img src="/images/mergeSort.gif" alt="mergeSort3"></p>
<p><em>图引自 <a class="link"   href="https://www.runoob.com/w3cnote/merge-sort.html" >1.5 归并排序<i class="fas fa-external-link-alt"></i></a></em> </p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>平均时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
<p>​        从上面的分析不难看出，归并排序的时间复杂度相对稳定，不管元素在什么情况下都要做一样的步骤，所以花销的时间是不变的，因此该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )。</p>
<p>​        而空间复杂度则需要考虑在排序的时候需要用到一个临时数组 O(n)，以及递归需要的递归栈空间 O(logn)，则空间复杂度应该为 O(n)。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>Java 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bai.mergesort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.bai.mergesort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/6 00:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: MergeSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Bai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/3/6 00:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 临时数组用于临时存放排序结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrayTmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        arrayTmp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将左右两边已排序的数组重新排序合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array     原数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left      数组左指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right     数组右指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeArray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 先将左右两边较小的数放到 tmp 数组中 */</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[j]) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  等价</span></span><br><span class="line"><span class="comment">                 *  arrayTmp[index] = array[i];</span></span><br><span class="line"><span class="comment">                 *  index++;</span></span><br><span class="line"><span class="comment">                 *  i++;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                arrayTmp[index++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arrayTmp[index++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 然后将左边剩下的数填充到 tmp 数组中 */</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            arrayTmp[index++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将右边剩下的数填充到 tmp 数组中 */</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            arrayTmp[index++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 最后将已排序的数组部分覆盖到原数组 */</span></span><br><span class="line">        index = left;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= right) &#123;</span><br><span class="line">            array[index] = arrayTmp[index];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用递归对数组进行归并排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array    原数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left     数组左指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right    数组右指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* 将数组二分，分别对左右两个数组进行归并排序 */</span></span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 左右两边已经排序好的数组进行重新排序组合 */</span></span><br><span class="line">        mergeArray(array, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试验证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        MergeSort mergeSort = <span class="keyword">new</span> MergeSort(arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort.mergeSort(arr, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>C++ 代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将分为两边的有序数组，合并为一个有序数组</span></span><br><span class="line"><span class="comment">// [IN] int array[]    原数组</span></span><br><span class="line"><span class="comment">// [IN] int arrayTmp[] 临时数组</span></span><br><span class="line"><span class="comment">// [IN] int left       数组左边指针</span></span><br><span class="line"><span class="comment">// [IN] int right      数组右边指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> arrayTmp[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = left;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次比较左右两边的数组，有序放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[j]) &#123;</span><br><span class="line">            arrayTmp[index++] =  <span class="built_in">array</span>[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrayTmp[index++] =  <span class="built_in">array</span>[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将左侧数组中剩下的数放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        arrayTmp[index++] = <span class="built_in">array</span>[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将右侧数组中剩下的数放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        arrayTmp[index++] = <span class="built_in">array</span>[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将临时数组中已经排序好的数组覆盖原数组的对应部分</span></span><br><span class="line">    index =  left;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= right) &#123;</span><br><span class="line">        <span class="built_in">array</span>[index] = arrayTmp[index];</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归实现无序数组的归并排序</span></span><br><span class="line"><span class="comment">// [IN] int array[]    原数组</span></span><br><span class="line"><span class="comment">// [IN] int arrayTmp[] 临时数组</span></span><br><span class="line"><span class="comment">// [IN] int left       数组左边指针</span></span><br><span class="line"><span class="comment">// [IN] int right      数组右边指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> arrayTmp[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = left + (right -  left) / <span class="number">2</span>;</span><br><span class="line">    MergeSort(<span class="built_in">array</span>, arrayTmp, left, mid);</span><br><span class="line">    MergeSort(<span class="built_in">array</span>, arrayTmp, mid + <span class="number">1</span>, right);</span><br><span class="line">    MergeArray(<span class="built_in">array</span>, arrayTmp, left, right);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************************</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> ****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[len] = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arrayTmp[len];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    MergeSort(<span class="built_in">array</span>, arrayTmp, left, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>在进行归并排序的时候，同时也衍生了一个比较巧妙的应用——逆序对。</p>
<blockquote>
<p>对于一个包含N个非负整数的数组A[1..n]，如果有i &lt; j，且A[ i ]&gt;A[ j ]，则称(A[ i] ,A[ j] )为数组A中的一个逆序对。</p>
</blockquote>
<p>例如 LeetCode 上的这道题 <a class="link"   href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" >315.计算右侧小于当前元素的个数<i class="fas fa-external-link-alt"></i></a></p>
<p>结合前面的归并排序过程，不难发现，每次在合并左右两个序列的时候，其实都是在查找逆序对。</p>
<p><img src="/images/mergeSort3.png" alt="mergeSort3"></p>
<p>在步骤 c 中，</p>
<ul>
<li>先判断 7 和 5，这是一组逆序对</li>
<li>然后判断 6 和 4，这是第二组逆序对</li>
</ul>
<p>在步骤 d 中，比较两个数组 [5, 7] 和 [4, 6]，</p>
<ul>
<li>首先 5 &lt; 4，因此在左边数组中会存在两个大于 4 的数，因此这里有两组逆序对，一共 4 组逆序对</li>
<li>继续比较 5 放到临时队列中</li>
<li>比较到 7 和 6  的时候，左边数组中只有一个 7 比 6 大，因此这里有一组逆序对，一共 5 组逆序对</li>
</ul>
<p>通过以上的步骤就能计算出最后总的逆序对。</p>
<p>这里还有另外一道延伸的题：<a class="link"   href="https://binarysearch.com/problems/Triple-Inversion" >Triple Inversion<i class="fas fa-external-link-alt"></i></a></p>
<p>参考：<br><a class="link"   href="https://www.cnblogs.com/noKing/p/7940531.html" >归并排序及优化(Java实现)<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.runoob.com/w3cnote/merge-sort.html" >1.5 归并排序<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zhuanlan.zhihu.com/p/124356219" >【算法】排序算法之归并排序<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/chengxiao/p/6194356.html" >图解排序算法(四)之归并排序<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.jianshu.com/p/e6530cb7aa66" >经典算法问题：数组中的逆序对<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/DERRANTCM/article/details/46761051" >【剑指Offer学习】【面试题36：数组中的逆序对】<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://www.cnblogs.com/chengxiao/p/6194356.html" >https://www.cnblogs.com/chengxiao/p/6194356.html<i class="fas fa-external-link-alt"></i></a>)</p>
]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>数据结构及算法</tag>
      </tags>
  </entry>
</search>
