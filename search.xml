<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1381.设计一个支持增量操作的栈</title>
    <url>/yrylalala.github.io/2021/03/25/1381.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h3 id="题目地址-1381-设计一个支持增量操作的栈"><a href="#题目地址-1381-设计一个支持增量操作的栈" class="headerlink" title="题目地址(1381. 设计一个支持增量操作的栈)"></a>题目地址(1381. 设计一个支持增量操作的栈)</h3><p><a class="link"   href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" >https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请你设计一个支持下述操作的栈。</span><br><span class="line"></span><br><span class="line">实现自定义栈类 CustomStack ：</span><br><span class="line">CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。</span><br><span class="line">void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。</span><br><span class="line">int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。</span><br><span class="line">void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span><br><span class="line">[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,2,null,null,null,null,null,103,202,201,-1]</span><br><span class="line">解释：</span><br><span class="line">CustomStack customStack &#x3D; new CustomStack(3); &#x2F;&#x2F; 栈是空的 []</span><br><span class="line">customStack.push(1);                          &#x2F;&#x2F; 栈变为 [1]</span><br><span class="line">customStack.push(2);                          &#x2F;&#x2F; 栈变为 [1, 2]</span><br><span class="line">customStack.pop();                            &#x2F;&#x2F; 返回 2 --&gt; 返回栈顶值 2，栈变为 [1]</span><br><span class="line">customStack.push(2);                          &#x2F;&#x2F; 栈变为 [1, 2]</span><br><span class="line">customStack.push(3);                          &#x2F;&#x2F; 栈变为 [1, 2, 3]</span><br><span class="line">customStack.push(4);                          &#x2F;&#x2F; 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4</span><br><span class="line">customStack.increment(5, 100);                &#x2F;&#x2F; 栈变为 [101, 102, 103]</span><br><span class="line">customStack.increment(2, 100);                &#x2F;&#x2F; 栈变为 [201, 202, 103]</span><br><span class="line">customStack.pop();                            &#x2F;&#x2F; 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202]</span><br><span class="line">customStack.pop();                            &#x2F;&#x2F; 返回 202 --&gt; 返回栈顶值 202，栈变为 [201]</span><br><span class="line">customStack.pop();                            &#x2F;&#x2F; 返回 201 --&gt; 返回栈顶值 201，栈变为 []</span><br><span class="line">customStack.pop();                            &#x2F;&#x2F; 返回 -1 --&gt; 栈为空，返回 -1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; maxSize &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; x &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; val &lt;&#x3D; 100</span><br><span class="line">每种方法 increment，push 以及 pop 分别最多调用 1000 次</span><br></pre></td></tr></table></figure>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>栈</li>
<li>数组</li>
<li>前缀和</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于出栈入栈比较好实现，这里其实直接用 int[] 还能提高一些效率，不需要调用封装的集合。<br>难点在于实现增量，比较暴力的方法就是遍历一遍前 K 个数，然后将这些书都做一遍增量的操作，但是这样时间复杂度比较高。<br>优化一下，使用前缀和。<br>另外使用一个数组作为增量数组，每一次增量操作，将增量添加到对应的 K - 1 的位置上。<br>出栈时，将原来存数据的栈顶元素加上对应的增量栈顶元素，并将增量栈的栈顶元素值赋给前面一个元素并出栈。<br>入栈时，增量栈的数组末尾直接添加 0 即可。</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li> 利用前缀和可以实现每次操作只用 O(1)</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：Java、C++</li>
</ul>
<p>Java Code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; nums;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; pres;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxLen;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;&gt;(maxSize);</span><br><span class="line">        pres = <span class="keyword">new</span> ArrayList&lt;&gt;(maxSize);</span><br><span class="line">        maxLen = maxSize; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxLen == nums.size()) <span class="keyword">return</span>;</span><br><span class="line">        nums.add(x);</span><br><span class="line">        pres.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = nums.get(nums.size() -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = pres.get(pres.size() - <span class="number">1</span>);</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        pres.remove(pres.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pres.isEmpty()) &#123;</span><br><span class="line">            pres.set(pres.size() - <span class="number">1</span>, pres.get(pres.size() - <span class="number">1</span>) + pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last + pre;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.size()) &#123;</span><br><span class="line">            pres.set(pres.size() - <span class="number">1</span>, pres.get(pres.size() - <span class="number">1</span>) + val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pres.set(k - <span class="number">1</span>, pres.get(k - <span class="number">1</span>) + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CustomStack obj = new CustomStack(maxSize);</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * obj.increment(k,val);</span></span><br></pre></td></tr></table></figure>
<p>C++ Code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CustomStack(<span class="keyword">int</span> maxSize) &#123;</span><br><span class="line">        stack_ = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxSize, <span class="number">0</span>);</span><br><span class="line">        incrementVec = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxSize, <span class="number">0</span>);</span><br><span class="line">        stackMax = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackLen == stackMax) <span class="keyword">return</span>;</span><br><span class="line">        stackLen++;</span><br><span class="line">        stack_[stackLen - <span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = stack_[stackLen - <span class="number">1</span>] + incrementVec[stackLen - <span class="number">1</span>];</span><br><span class="line">        stack_[stackLen - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (stackLen &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            incrementVec[stackLen - <span class="number">2</span>] +=  incrementVec[stackLen - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        incrementVec[stackLen - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        stackLen--;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackLen == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; stackLen) &#123;</span><br><span class="line">            incrementVec[stackLen - <span class="number">1</span>] += val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            incrementVec[k <span class="number">-1</span>] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; incrementVec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stack_;</span><br><span class="line">    <span class="keyword">int</span> stackLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> stackMax = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong><br>令 n 为数组长度，即栈的最大长度。</p>
<ul>
<li>时间复杂度：$O(1)$，所有的操作都是直接操作对应索引的元素，因此只需要 O(1)。</li>
<li>空间复杂度：$O(n)$，需要两个等大的数组空间用来做为栈。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构及算法</tag>
        <tag>栈</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>394.字符串解码</title>
    <url>/yrylalala.github.io/2021/03/25/394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h3 id="题目地址-394-字符串解码"><a href="#题目地址-394-字符串解码" class="headerlink" title="题目地址(394. 字符串解码)"></a>题目地址(394. 字符串解码)</h3><p><a class="link"   href="https://leetcode-cn.com/problems/decode-string/" >https://leetcode-cn.com/problems/decode-string/<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个经过编码的字符串，返回它解码后的字符串。</span><br><span class="line">编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</span><br><span class="line">你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</span><br><span class="line">此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s &#x3D; &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：s &#x3D; &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>栈</li>
<li>递归</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两个思路</p>
<ol>
<li><p>使用两个栈，数字栈和字符串栈，从前往后遍历<br>a. 当遍历到数字的时候，拼接数字 curNum；<br>b. 当遍历到 ‘[‘ 的时候，将数字压入到数字栈中；<br>c. 当遍历到字母的时候，拼接字符串 curSub；<br>d. 当遍历到 ‘]’ 的时候，数字栈中出栈，根据数字拼接对应个数的字符串，然后压入栈中；<br>e. 最后返回字符串栈顶元素；</p>
</li>
<li><p>使用递归，遍历字符串， 每一对 ‘[ ]’ 内就是一层递归，<br>a. 遍历到数字时记录数字；<br>b. 遍历到 ‘[‘ 时，递归调用 ；<br>c. 遍历到字符时，拼接当前字符串；<br>d. 遍历到 ‘]’ 时，返回当前拼接的字符串；  </p>
</li>
</ol>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>思路 1 中：</p>
<ul>
<li> 需要用两个栈，尤其是字符串栈，栈的元素是当前 ‘[ ]’ 中的字符串，而不是遍历的字母</li>
</ul>
</li>
<li><p>思路 2 中：</p>
<ul>
<li><p>递归调用的每一层就是 ‘[ ]’ 内的字符串</p>
</li>
<li><p>虽然是递归调用，但是遍历只用一次，因此遍历的索引值是一个全局变量值</p>
<p>Java 使用 StringBuilder 会大幅度优化最后的结果。</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路 1 的实现：</p>
<ul>
<li>语言支持：Java</li>
</ul>
<p>Java Code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder curStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder curNum = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Integer num = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stackNum = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        ArrayDeque&lt;StringBuilder&gt; stackStr = <span class="keyword">new</span> ArrayDeque&lt;StringBuilder&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">/* 将遍历到的数字和字符串压入栈中 */</span></span><br><span class="line">                num = Integer.parseInt(curNum.toString());</span><br><span class="line">                stackNum.push(num);</span><br><span class="line">                stackStr.push(curStr);</span><br><span class="line">                curNum = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                curStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">/* 当遍历到中括号结尾 将字符串和数字出栈 拼接 */</span></span><br><span class="line">                StringBuilder ansTmp = stackStr.pop();</span><br><span class="line">                <span class="keyword">int</span> strNum = stackNum.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strNum; i++) &#123;</span><br><span class="line">                    ansTmp.append(curStr);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 将拼接好的字符串赋给当前遍历生成的字符串变量 */</span></span><br><span class="line">                curStr = ansTmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="comment">/* 当字符是数字 */</span></span><br><span class="line">                curNum.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 当字符是字母 */</span></span><br><span class="line">                curStr.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curStr.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong><br>令 n 为字符串长度。</p>
<ul>
<li>  时间复杂度：$O(n)$, 从前往后遍历了一遍字符串。</li>
<li>  空间复杂度：$O(n)$, 使用了额外的栈空间保存遍历的字符串。</li>
</ul>
<p>思路 2 的实现：</p>
<ul>
<li>语言支持：Java、C++</li>
</ul>
<p>Java Code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sub = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">            sub.append(getSub(s));</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sub.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">getSub</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sub = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(index) &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s.charAt(index) &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                num = num*<span class="number">10</span> + (s.charAt(index) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                index++;</span><br><span class="line">                StringBuilder subTmp = getSub(s);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                    sub.append(subTmp);</span><br><span class="line">                &#125;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> sub;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sub.append(s.charAt(index));</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>C++ Code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 遍历索引值，每一层的调用栈都是使用同一个索引值</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">help</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> ansTmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pos &lt; s.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[pos] == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 递归返回 [] 内子串</span></span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[pos] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 继续进入递归 遍历 [] 内的子串</span></span><br><span class="line">                pos++;</span><br><span class="line">                <span class="built_in">string</span> sub = help(s);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                    ret += sub;</span><br><span class="line">                &#125;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt; s[pos] &amp;&amp; s[pos] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前字符为数字 记录当前 [ 前的数字</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + (s[pos] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125; <span class="keyword">while</span> (s[pos] != <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">                pos--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前字符为字母 直接拼接</span></span><br><span class="line">                ret += s[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong><br>令 n 为字符串长度。</p>
<ul>
<li>时间复杂度：$O(n)$，只遍历了一次字符串</li>
<li>空间复杂度：$O(n)$，递归调用需要使用递归栈。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构及算法</tag>
        <tag>栈</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>821.字符的最短距离</title>
    <url>/yrylalala.github.io/2021/03/03/821.%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a class="link"   href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/" >https://leetcode-cn.com/problems/shortest-distance-to-a-character/<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：S &#x3D; &quot;loveleetcode&quot;, C &#x3D; &#39;e&#39;</span><br><span class="line">输出：[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">字符串 S 的长度范围为 [1, 10000]。</span><br><span class="line">C 是一个单字符，且保证是字符串 S 里的字符。</span><br><span class="line">S 和 C 中的所有字母均为小写字母。</span><br></pre></td></tr></table></figure>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>数组遍历</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>遍历该字符串，找到对应的字符，然后以该字符的位置向左右扩展，计算距离</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li> 需要注意遍历的判断条件</li>
</ul>
<ol>
<li>当遍历到的字符位置距离值还是 0 的时候填充距离，并继续扩展</li>
<li>当遍历到的字符位置距离值小于已填充的距离值值时填充距离，并继续扩展</li>
<li>当遇到字符串左右边界的时候返回</li>
<li>当遇到同样字符 C 的时候返回</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：Java</li>
</ul>
<p>Java Code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (C == S.charAt(i)) &#123;</span><br><span class="line">                left = i - <span class="number">1</span>;</span><br><span class="line">                right = i + <span class="number">1</span>;</span><br><span class="line">                ret[i] = <span class="number">0</span>;</span><br><span class="line">                dist = <span class="number">1</span>;</span><br><span class="line">               <span class="comment">/* 向左延伸 +*/</span></span><br><span class="line">                <span class="keyword">while</span> ((left &gt;= <span class="number">0</span>) &amp;&amp; </span><br><span class="line">                       (S.charAt(left) != C) &amp;&amp;</span><br><span class="line">                       (ret[left] == <span class="number">0</span> || ret[left] &gt; dist)) &#123;</span><br><span class="line">                        ret[left] = dist;</span><br><span class="line">                        dist++;</span><br><span class="line">                        left--;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">/* 向右延伸 */</span></span><br><span class="line">                dist = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ((right &lt; S.length()) &amp;&amp; </span><br><span class="line">                       (S.charAt(right) != C) &amp;&amp; </span><br><span class="line">                       (ret[right] == <span class="number">0</span> || ret[right] &gt; dist)) &#123;</span><br><span class="line">                    ret[right] = dist;</span><br><span class="line">                    dist++;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong><br>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：O(n)，理论上是遍历两遍数组，循环查找字符 C，然后再从 C 开始扩展。</li>
<li>空间复杂度：O(n)，只需要额外只用一个数组空间用来存返回值即可。</li>
</ul>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h3><p>另外一个比较巧妙的办法是<br>先从头遍历一遍字符串，计算每个位置的字符到前一个字符 C 的距离<br>再从尾遍历一遍字符串，再用同样方法计算距离，若距离小于已填充的，就替换成新的距离</p>
<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li> 怎么保证两头的字符位置计算</li>
</ul>
<ol>
<li>从头开始遍历时，距离初始值为 -10001，因为字符最大长度是 10000，这样在出现第一个字符 C 之前的距离值全为负值<br> 而倒过来遍历的时候若距离值为负数，就可以直接覆盖</li>
<li>从尾开始遍历时，距离初始值为 10001，这样在开始遍历的时候，一定是小于已填充的距离值</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul>
<li>语言支持：C++  </li>
</ul>
<p>C++ Code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shortestToChar</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">char</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distVec</span><span class="params">(S.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从头到尾遍历</span></span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">-10001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == C) &#123;</span><br><span class="line">                distVec[i] = <span class="number">0</span>;</span><br><span class="line">                dist = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                distVec[i] = dist;</span><br><span class="line">                dist++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尾到头遍历</span></span><br><span class="line">        dist = <span class="number">10001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == C) &#123;</span><br><span class="line">                distVec[i] = <span class="number">0</span>;</span><br><span class="line">                dist = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (distVec[i] &lt; <span class="number">0</span> || distVec[i] &gt; dist) &#123;</span><br><span class="line">                    distVec[i] = dist;</span><br><span class="line">                    dist++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distVec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong><br>令 n 为数组长度。</p>
<ul>
<li>时间复杂度：O(n)，需要遍历两边数组</li>
<li>空间复杂度：O(n)，需要返回值的额外空间</li>
</ul>
]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构及算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/yrylalala.github.io/2021/03/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="过程理解"><a href="#过程理解" class="headerlink" title="过程理解"></a>过程理解</h3><p>​        归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br><strong>理解归并排序之前最好先对二分法有一定的理解，对于代码实现也有帮助。</strong> </p>
<p>以下这张图的步骤描述，相对来说比较清晰：<br><img src="/images/mergeSort/mergeSort1.jpeg" alt="mergeSort1"><br><em>图引自 <a class="link"   href="https://zhuanlan.zhihu.com/p/124356219" >【算法】排序算法之归并排序<i class="fas fa-external-link-alt"></i></a></em> </p>
<p>​        归并排序是用分治思想，分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之。因此规避排序在每一层递归上有三个步骤：</p>
<ul>
<li><strong>分解（Divide）</strong>：将 n 个元素分成个含 n/2 个元素的子序列。</li>
<li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li>
<li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li>
</ul>
<p><img src="/images/mergeSort/mergeSort2.png" alt="mergeSort2"><br><em>图引自 <a class="link"   href="https://www.cnblogs.com/chengxiao/p/6194356.html" >图解排序算法(四)之归并排序<i class="fas fa-external-link-alt"></i></a></em> </p>
<p>转为需要代码实现的时候，即可以借助以下图片来理解一下，不管是使用递归还是使用迭代。<br><img src="/images/mergeSort/mergeSort.gif" alt="mergeSort3"></p>
<p><em>图引自 <a class="link"   href="https://www.runoob.com/w3cnote/merge-sort.html" >1.5 归并排序<i class="fas fa-external-link-alt"></i></a></em> </p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>平均时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
<p>​        从上面的分析不难看出，归并排序的时间复杂度相对稳定，不管元素在什么情况下都要做一样的步骤，所以花销的时间是不变的，因此该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )。</p>
<p>​        而空间复杂度则需要考虑在排序的时候需要用到一个临时数组 O(n)，以及递归需要的递归栈空间 O(logn)，则空间复杂度应该为 O(n)。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>Java 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bai.mergesort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.bai.mergesort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/6 00:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: MergeSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Bai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/3/6 00:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 临时数组用于临时存放排序结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrayTmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        arrayTmp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将左右两边已排序的数组重新排序合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array     原数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left      数组左指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right     数组右指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeArray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 先将左右两边较小的数放到 tmp 数组中 */</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[j]) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  等价</span></span><br><span class="line"><span class="comment">                 *  arrayTmp[index] = array[i];</span></span><br><span class="line"><span class="comment">                 *  index++;</span></span><br><span class="line"><span class="comment">                 *  i++;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                arrayTmp[index++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arrayTmp[index++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 然后将左边剩下的数填充到 tmp 数组中 */</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            arrayTmp[index++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将右边剩下的数填充到 tmp 数组中 */</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            arrayTmp[index++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 最后将已排序的数组部分覆盖到原数组 */</span></span><br><span class="line">        index = left;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= right) &#123;</span><br><span class="line">            array[index] = arrayTmp[index];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用递归对数组进行归并排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array    原数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left     数组左指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right    数组右指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* 将数组二分，分别对左右两个数组进行归并排序 */</span></span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 左右两边已经排序好的数组进行重新排序组合 */</span></span><br><span class="line">        mergeArray(array, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试验证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        MergeSort mergeSort = <span class="keyword">new</span> MergeSort(arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort.mergeSort(arr, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>C++ 代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将分为两边的有序数组，合并为一个有序数组</span></span><br><span class="line"><span class="comment">// [IN] int array[]    原数组</span></span><br><span class="line"><span class="comment">// [IN] int arrayTmp[] 临时数组</span></span><br><span class="line"><span class="comment">// [IN] int left       数组左边指针</span></span><br><span class="line"><span class="comment">// [IN] int right      数组右边指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> arrayTmp[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = left;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次比较左右两边的数组，有序放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[j]) &#123;</span><br><span class="line">            arrayTmp[index++] =  <span class="built_in">array</span>[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrayTmp[index++] =  <span class="built_in">array</span>[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将左侧数组中剩下的数放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        arrayTmp[index++] = <span class="built_in">array</span>[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将右侧数组中剩下的数放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        arrayTmp[index++] = <span class="built_in">array</span>[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将临时数组中已经排序好的数组覆盖原数组的对应部分</span></span><br><span class="line">    index =  left;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= right) &#123;</span><br><span class="line">        <span class="built_in">array</span>[index] = arrayTmp[index];</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归实现无序数组的归并排序</span></span><br><span class="line"><span class="comment">// [IN] int array[]    原数组</span></span><br><span class="line"><span class="comment">// [IN] int arrayTmp[] 临时数组</span></span><br><span class="line"><span class="comment">// [IN] int left       数组左边指针</span></span><br><span class="line"><span class="comment">// [IN] int right      数组右边指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> arrayTmp[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = left + (right -  left) / <span class="number">2</span>;</span><br><span class="line">    MergeSort(<span class="built_in">array</span>, arrayTmp, left, mid);</span><br><span class="line">    MergeSort(<span class="built_in">array</span>, arrayTmp, mid + <span class="number">1</span>, right);</span><br><span class="line">    MergeArray(<span class="built_in">array</span>, arrayTmp, left, right);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************************</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> ****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[len] = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arrayTmp[len];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    MergeSort(<span class="built_in">array</span>, arrayTmp, left, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>在进行归并排序的时候，同时也衍生了一个比较巧妙的应用——逆序对。</p>
<blockquote>
<p>对于一个包含N个非负整数的数组A[1..n]，如果有i &lt; j，且A[ i ]&gt;A[ j ]，则称(A[ i] ,A[ j] )为数组A中的一个逆序对。</p>
</blockquote>
<p>例如 LeetCode 上的这道题 <a class="link"   href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" >315.计算右侧小于当前元素的个数<i class="fas fa-external-link-alt"></i></a></p>
<p>结合前面的归并排序过程，不难发现，每次在合并左右两个序列的时候，其实都是在查找逆序对。</p>
<p><img src="/images/mergeSort/mergeSort3.png" alt="mergeSort3"></p>
<p>在步骤 c 中，</p>
<ul>
<li>先判断 7 和 5，这是一组逆序对</li>
<li>然后判断 6 和 4，这是第二组逆序对</li>
</ul>
<p>在步骤 d 中，比较两个数组 [5, 7] 和 [4, 6]，</p>
<ul>
<li>首先 5 &lt; 4，因此在左边数组中会存在两个大于 4 的数，因此这里有两组逆序对，一共 4 组逆序对</li>
<li>继续比较 5 放到临时队列中</li>
<li>比较到 7 和 6  的时候，左边数组中只有一个 7 比 6 大，因此这里有一组逆序对，一共 5 组逆序对</li>
</ul>
<p>通过以上的步骤就能计算出最后总的逆序对。</p>
<p>这里还有另外一道延伸的题：<a class="link"   href="https://binarysearch.com/problems/Triple-Inversion" >Triple Inversion<i class="fas fa-external-link-alt"></i></a></p>
<p><strong><em>参考：</em></strong><br><a class="link"   href="https://www.cnblogs.com/noKing/p/7940531.html" >归并排序及优化(Java实现)<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.runoob.com/w3cnote/merge-sort.html" >1.5 归并排序<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zhuanlan.zhihu.com/p/124356219" >【算法】排序算法之归并排序<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/chengxiao/p/6194356.html" >图解排序算法(四)之归并排序<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.jianshu.com/p/e6530cb7aa66" >经典算法问题：数组中的逆序对<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/DERRANTCM/article/details/46761051" >【剑指Offer学习】【面试题36：数组中的逆序对】<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://www.cnblogs.com/chengxiao/p/6194356.html" >https://www.cnblogs.com/chengxiao/p/6194356.html<i class="fas fa-external-link-alt"></i></a>)</p>
]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>数据结构及算法</tag>
      </tags>
  </entry>
</search>
